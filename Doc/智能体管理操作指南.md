# 智能体管理操作指南

## 概述

本文档基于 Open Canvas 项目重构后的智能体配置系统，详细说明如何添加、删除和管理智能体。重构后的系统提供了统一的配置接口、模板系统和验证机制，大大简化了智能体的管理流程。

## 目录

1. [系统架构](#系统架构)
2. [添加智能体](#添加智能体)
3. [删除智能体](#删除智能体)
4. [编辑智能体](#编辑智能体)
5. [智能体模板](#智能体模板)
6. [配置验证](#配置验证)
7. [错误处理](#错误处理)
8. [最佳实践](#最佳实践)
9. [故障排除](#故障排除)

## 系统架构

### 重构后的智能体配置系统

```
packages/shared/src/config/
├── assistant-config.ts          # 智能体配置接口和验证器
└── model-config.ts             # 模型配置接口

config/
└── assistant-templates.json    # 智能体模板配置

apps/web/src/
├── components/assistant-select/ # 智能体选择组件
├── contexts/AssistantContext.tsx # 智能体上下文管理
└── hooks/use-error-handler.ts   # 错误处理Hook
```

### 核心组件

1. **AssistantConfig** - 智能体配置接口
2. **AssistantTemplate** - 智能体模板系统
3. **AssistantConfigValidator** - 配置验证器
4. **ErrorHandler** - 统一错误处理

## 添加智能体

### 方法一：使用智能体模板（推荐）

#### 1. 选择模板

```typescript
// 可用的智能体模板
const templates = [
  {
    id: "coding-assistant",
    name: "编程助手",
    category: "coding",
    description: "专业的代码编写和调试助手"
  },
  {
    id: "writing-assistant", 
    name: "写作助手",
    category: "writing",
    description: "专业的写作助手，帮助创作各种类型的文本内容"
  },
  {
    id: "data-analyst",
    name: "数据分析师", 
    category: "analysis",
    description: "专业的数据分析和可视化助手"
  }
];
```

#### 2. 基于模板创建智能体

```typescript
import { AssistantConfigValidator } from '@opencanvas/shared/config/assistant-config';
import { useAssistantContext } from '@/contexts/AssistantContext';

function CreateAssistantFromTemplate() {
  const { createCustomAssistant } = useAssistantContext();
  const { handleError } = useErrorHandler();

  const createFromTemplate = async (templateId: string, customizations: Partial<AssistantConfig>) => {
    try {
      // 1. 加载模板配置
      const template = await loadAssistantTemplate(templateId);
      
      // 2. 合并自定义配置
      const assistantConfig = {
        ...template.config,
        ...customizations,
        name: customizations.name || template.name,
        metadata: {
          ...template.config.metadata,
          createdAt: new Date(),
          updatedAt: new Date(),
          userId: currentUser.id,
        }
      };

      // 3. 验证配置
      const validation = AssistantConfigValidator.validate(assistantConfig);
      if (!validation.isValid) {
        throw new Error(`配置验证失败: ${validation.errors.map(e => e.message).join(', ')}`);
      }

      // 4. 创建智能体
      const assistant = await createCustomAssistant({
        newAssistant: assistantConfig,
        userId: currentUser.id,
        successCallback: (id) => {
          console.log(`智能体创建成功: ${id}`);
        }
      });

      return assistant;
    } catch (error) {
      await handleError(error, {
        operation: 'create_assistant_from_template',
        metadata: { templateId, customizations }
      });
      throw error;
    }
  };
}
```

### 方法二：自定义创建智能体

#### 1. 定义智能体配置

```typescript
import { CreateAssistantRequest, AssistantConfigValidator } from '@opencanvas/shared/config/assistant-config';

const customAssistantConfig: CreateAssistantRequest = {
  name: "我的自定义智能体",
  description: "专门用于处理特定任务的智能体",
  icon: {
    name: "Bot",
    color: "#3B82F6"
  },
  model: {
    id: "gpt-4o",
    config: {
      temperature: 0.7,
      maxTokens: 4096,
      toolCalling: true,
      streaming: true
    }
  },
  systemPrompt: "你是一个专业的助手，请始终保持友好和专业的态度。",
  tools: [
    {
      name: "custom_tool",
      description: "自定义工具",
      parameters: {
        type: "object",
        properties: {
          input: { type: "string", description: "输入参数" }
        },
        required: ["input"]
      }
    }
  ],
  documents: [],
  isDefault: false
};
```

#### 2. 验证并创建

```typescript
async function createCustomAssistant(config: CreateAssistantRequest) {
  // 1. 验证配置
  const validation = AssistantConfigValidator.validate(config);
  
  if (!validation.isValid) {
    const errorMessages = validation.errors.map(e => `${e.field}: ${e.message}`);
    throw new Error(`配置验证失败:\n${errorMessages.join('\n')}`);
  }

  // 2. 显示警告（如果有）
  if (validation.warnings.length > 0) {
    validation.warnings.forEach(warning => {
      console.warn(`配置警告: ${warning.field} - ${warning.message}`);
    });
  }

  // 3. 检查名称唯一性
  const existingAssistants = await getAssistants(currentUser.id);
  if (!AssistantConfigValidator.validateNameUniqueness(
    config.name, 
    existingAssistants
  )) {
    throw new Error(`智能体名称 "${config.name}" 已存在，请使用其他名称`);
  }

  // 4. 创建智能体
  const assistant = await createCustomAssistant({
    newAssistant: config,
    userId: currentUser.id
  });

  return assistant;
}
```

## 删除智能体

### 1. 安全删除检查

```typescript
import { useAssistantContext } from '@/contexts/AssistantContext';
import { useErrorHandler } from '@/hooks/use-error-handler';

function DeleteAssistantComponent() {
  const { deleteAssistant, selectedAssistant } = useAssistantContext();
  const { handleError } = useErrorHandler();

  const deleteAssistantSafely = async (assistantId: string) => {
    try {
      // 1. 检查是否为默认智能体
      if (selectedAssistant?.metadata?.isDefault) {
        throw new Error('不能删除默认智能体，请先设置其他智能体为默认');
      }

      // 2. 确认删除
      const confirmed = await showDeleteConfirmation({
        title: '确认删除智能体',
        message: `确定要删除智能体 "${selectedAssistant?.name}" 吗？此操作不可撤销。`,
        confirmText: '删除',
        cancelText: '取消'
      });

      if (!confirmed) {
        return;
      }

      // 3. 执行删除
      const success = await deleteAssistant(assistantId);
      
      if (success) {
        console.log('智能体删除成功');
        // 显示成功消息
        toast({
          title: '删除成功',
          description: '智能体已成功删除',
          variant: 'default'
        });
      } else {
        throw new Error('删除智能体失败');
      }

    } catch (error) {
      await handleError(error, {
        operation: 'delete_assistant',
        metadata: { assistantId }
      });
    }
  };
}
```

### 2. 批量删除

```typescript
async function batchDeleteAssistants(assistantIds: string[]) {
  const results = [];
  
  for (const id of assistantIds) {
    try {
      const success = await deleteAssistant(id);
      results.push({ id, success, error: null });
    } catch (error) {
      results.push({ id, success: false, error: error.message });
    }
  }

  // 显示批量删除结果
  const successCount = results.filter(r => r.success).length;
  const failCount = results.filter(r => !r.success).length;

  toast({
    title: '批量删除完成',
    description: `成功删除 ${successCount} 个智能体，失败 ${failCount} 个`,
    variant: failCount > 0 ? 'destructive' : 'default'
  });

  return results;
}
```

## 编辑智能体

### 1. 更新智能体配置

```typescript
import { UpdateAssistantRequest } from '@opencanvas/shared/config/assistant-config';

async function updateAssistant(assistantId: string, updates: Partial<CreateAssistantRequest>) {
  try {
    // 1. 获取当前配置
    const currentAssistant = await getAssistant(assistantId);
    if (!currentAssistant) {
      throw new Error('智能体不存在');
    }

    // 2. 合并更新
    const updatedConfig = {
      ...currentAssistant,
      ...updates,
      metadata: {
        ...currentAssistant.metadata,
        updatedAt: new Date()
      }
    };

    // 3. 验证更新后的配置
    const validation = AssistantConfigValidator.validate(updatedConfig);
    if (!validation.isValid) {
      throw new Error(`配置验证失败: ${validation.errors.map(e => e.message).join(', ')}`);
    }

    // 4. 检查名称唯一性（如果名称有变化）
    if (updates.name && updates.name !== currentAssistant.name) {
      const existingAssistants = await getAssistants(currentUser.id);
      if (!AssistantConfigValidator.validateNameUniqueness(
        updates.name,
        existingAssistants,
        assistantId
      )) {
        throw new Error(`智能体名称 "${updates.name}" 已存在`);
      }
    }

    // 5. 执行更新
    const updatedAssistant = await editCustomAssistant({
      editedAssistant: updatedConfig,
      assistantId,
      userId: currentUser.id
    });

    return updatedAssistant;
  } catch (error) {
    await handleError(error, {
      operation: 'update_assistant',
      metadata: { assistantId, updates }
    });
    throw error;
  }
}
```

### 2. 部分更新

```typescript
// 只更新模型配置
await updateAssistant(assistantId, {
  model: {
    id: "claude-3-5-sonnet-latest",
    config: {
      temperature: 0.3,
      maxTokens: 8192,
      toolCalling: true,
      streaming: true
    }
  }
});

// 只更新系统提示
await updateAssistant(assistantId, {
  systemPrompt: "新的系统提示内容..."
});

// 只更新工具配置
await updateAssistant(assistantId, {
  tools: [
    {
      name: "new_tool",
      description: "新工具",
      parameters: { /* 参数定义 */ }
    }
  ]
});
```

## 智能体模板

### 1. 使用现有模板

```typescript
// 加载模板列表
const templates = await loadAssistantTemplates();

// 按分类筛选
const codingTemplates = templates.filter(t => t.category === 'coding');
const writingTemplates = templates.filter(t => t.category === 'writing');
```

### 2. 创建自定义模板

```typescript
// 在 config/assistant-templates.json 中添加新模板
{
  "templates": [
    {
      "id": "custom-template",
      "name": "自定义模板",
      "description": "用于特定场景的智能体模板",
      "category": "custom",
      "config": {
        "model": {
          "id": "gpt-4o",
          "config": {
            "temperature": 0.5,
            "maxTokens": 4096,
            "toolCalling": true,
            "streaming": true
          }
        },
        "systemPrompt": "你是一个专业的助手...",
        "tools": []
      },
      "preview": {
        "icon": "Star",
        "color": "#F59E0B",
        "description": "自定义模板描述"
      }
    }
  ]
}
```

## 配置验证

### 1. 自动验证

系统会在以下时机自动验证配置：
- 创建智能体时
- 更新智能体时
- 导入配置时

### 2. 验证规则

```typescript
// 必填字段验证
- name: 不能为空，长度不超过100字符
- icon.name: 不能为空
- icon.color: 必须是有效的十六进制颜色值
- model.id: 不能为空
- model.config.temperature: 必须在0-1之间
- model.config.maxTokens: 必须在1-100000之间

// 可选字段验证
- description: 建议不超过500字符
- systemPrompt: 建议不超过10000字符
- tools: 每个工具必须有name、description和parameters
```

### 3. 自定义验证

```typescript
// 扩展验证器
class CustomAssistantValidator extends AssistantConfigValidator {
  static validateCustom(config: Partial<AssistantConfig>): AssistantValidationResult {
    const baseValidation = super.validate(config);
    const customErrors: AssistantValidationError[] = [];

    // 添加自定义验证规则
    if (config.name && config.name.includes('测试')) {
      customErrors.push({
        field: 'name',
        message: '智能体名称不能包含"测试"字样',
        code: 'INVALID_NAME'
      });
    }

    return {
      isValid: baseValidation.isValid && customErrors.length === 0,
      errors: [...baseValidation.errors, ...customErrors],
      warnings: baseValidation.warnings
    };
  }
}
```

## 错误处理

### 1. 统一错误处理

```typescript
import { AssistantError, AssistantErrorCode } from '@opencanvas/shared/config/assistant-config';

try {
  await createAssistant(config);
} catch (error) {
  if (error instanceof AssistantError) {
    switch (error.code) {
      case AssistantErrorCode.ASSISTANT_CREATION_FAILED:
        // 处理创建失败
        break;
      case AssistantErrorCode.INVALID_ASSISTANT_CONFIG:
        // 处理配置无效
        break;
      case AssistantErrorCode.DUPLICATE_ASSISTANT_NAME:
        // 处理名称重复
        break;
      default:
        // 处理其他错误
        break;
    }
  }
}
```

### 2. 用户友好的错误消息

```typescript
const errorMessages = {
  [AssistantErrorCode.ASSISTANT_NOT_FOUND]: '智能体不存在',
  [AssistantErrorCode.ASSISTANT_CREATION_FAILED]: '创建智能体失败，请检查配置后重试',
  [AssistantErrorCode.INVALID_ASSISTANT_CONFIG]: '智能体配置无效，请检查配置',
  [AssistantErrorCode.DUPLICATE_ASSISTANT_NAME]: '智能体名称已存在，请使用其他名称'
};
```

## 最佳实践

### 1. 智能体命名规范

```typescript
// 推荐的命名方式
const goodNames = [
  "编程助手",
  "数据分析师", 
  "写作助手",
  "客服助手",
  "翻译助手"
];

// 避免的命名方式
const badNames = [
  "助手1",           // 太简单
  "我的超级智能体",   // 太长
  "test",           // 英文
  "助手@#$%",       // 特殊字符
  ""                // 空名称
];
```

### 2. 模型选择建议

```typescript
// 不同场景的模型推荐
const modelRecommendations = {
  coding: {
    primary: "gpt-4o",
    fallback: "claude-3-5-sonnet-latest",
    reason: "代码生成和调试能力强"
  },
  writing: {
    primary: "claude-3-5-sonnet-latest", 
    fallback: "gpt-4o",
    reason: "文本创作和润色能力强"
  },
  analysis: {
    primary: "gpt-4o",
    fallback: "gemini-2.0-flash",
    reason: "逻辑分析和数据处理能力强"
  }
};
```

### 3. 系统提示编写

```typescript
// 好的系统提示示例
const goodSystemPrompt = `
你是一个专业的编程助手，擅长多种编程语言。

你的职责：
1. 编写高质量的代码
2. 调试和修复代码错误  
3. 解释复杂的编程概念
4. 提供最佳实践建议

请始终保持：
- 代码的清晰性和可读性
- 详细的注释和说明
- 考虑性能和安全性
`;

// 避免的系统提示
const badSystemPrompt = "你是助手"; // 太简单，缺乏指导性
```

### 4. 工具配置

```typescript
// 工具配置最佳实践
const toolConfig = {
  name: "code_generator",           // 使用下划线命名
  description: "生成代码片段",      // 清晰描述功能
  parameters: {
    type: "object",
    properties: {
      language: {
        type: "string",
        description: "编程语言",
        enum: ["python", "javascript", "typescript", "java"]
      },
      task: {
        type: "string", 
        description: "代码任务描述"
      }
    },
    required: ["language", "task"]  // 明确必填参数
  }
};
```

## 故障排除

### 1. 常见问题

#### 问题：智能体创建失败
**可能原因：**
- 配置验证失败
- 网络连接问题
- 权限不足

**解决方案：**
```typescript
// 1. 检查配置
const validation = AssistantConfigValidator.validate(config);
if (!validation.isValid) {
  console.error('配置错误:', validation.errors);
}

// 2. 检查网络
try {
  await fetch('/api/health');
} catch (error) {
  console.error('网络连接失败:', error);
}

// 3. 检查权限
const user = await getCurrentUser();
if (!user) {
  throw new Error('用户未登录');
}
```

#### 问题：智能体名称重复
**解决方案：**
```typescript
// 自动生成唯一名称
function generateUniqueName(baseName: string, existingNames: string[]): string {
  let uniqueName = baseName;
  let counter = 1;
  
  while (existingNames.includes(uniqueName)) {
    uniqueName = `${baseName} (${counter})`;
    counter++;
  }
  
  return uniqueName;
}
```

#### 问题：模型调用失败
**解决方案：**
```typescript
// 实现模型回退机制
async function createAssistantWithFallback(config: CreateAssistantRequest) {
  const primaryModel = config.model.id;
  const fallbackModels = getFallbackModels(primaryModel);
  
  for (const modelId of [primaryModel, ...fallbackModels]) {
    try {
      const testConfig = { ...config, model: { ...config.model, id: modelId } };
      await testModelConnection(modelId);
      return await createAssistant(testConfig);
    } catch (error) {
      console.warn(`模型 ${modelId} 不可用，尝试下一个`);
      continue;
    }
  }
  
  throw new Error('所有模型都不可用');
}
```

### 2. 调试技巧

#### 启用调试模式
```typescript
// 在开发环境中启用详细日志
if (process.env.NODE_ENV === 'development') {
  console.log('智能体配置:', JSON.stringify(config, null, 2));
  console.log('验证结果:', validation);
}
```

#### 使用错误边界
```typescript
import { ErrorBoundary } from '@/components/error-boundary/error-boundary';

function AssistantManagement() {
  return (
    <ErrorBoundary componentName="AssistantManagement">
      {/* 智能体管理组件 */}
    </ErrorBoundary>
  );
}
```

### 3. 性能优化

#### 缓存智能体列表
```typescript
import { useAssistantCache } from '@/hooks/use-model-cache';

function useOptimizedAssistants() {
  const { getCachedAssistants, setAssistantsCache } = useAssistantCache();
  
  const getAssistants = useCallback(async (userId: string) => {
    // 先尝试从缓存获取
    const cached = await getCachedAssistants(userId);
    if (cached) {
      return cached;
    }
    
    // 缓存未命中，从API获取
    const assistants = await fetchAssistants(userId);
    await setAssistantsCache(userId, assistants);
    return assistants;
  }, [getCachedAssistants, setAssistantsCache]);
  
  return { getAssistants };
}
```

## 总结

重构后的智能体管理系统提供了：

1. **统一的配置接口** - 标准化的智能体配置结构
2. **模板系统** - 快速创建常用类型的智能体
3. **完整的验证机制** - 确保配置的正确性
4. **友好的错误处理** - 清晰的错误信息和恢复建议
5. **性能优化** - 缓存和资源管理
6. **最佳实践指导** - 帮助用户创建高质量的智能体

通过遵循本文档的指导，您可以高效地管理 Open Canvas 项目中的智能体，提升开发效率和用户体验。
