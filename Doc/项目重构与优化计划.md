# Open Canvas 项目重构与优化计划

## 概述

基于对当前 Open Canvas 项目的深入分析，本文档制定了一个全面的重构与优化计划，旨在解决模型配置复杂、智能体配置繁琐、错误处理不完善等核心问题，提升代码质量、性能和用户体验。

## 1. 当前问题分析

### 1.1 模型配置问题

**问题描述：**
- 新增模型需要修改多个文件（`models.ts`、`utils.ts`、环境变量等）
- 模型配置分散在多个位置，维护困难
- 硬编码的模型列表，缺乏动态配置能力
- 重复的配置代码和复杂的条件判断

**影响范围：**
- `packages/shared/src/models.ts` - 640行硬编码模型配置
- `apps/agents/src/utils.ts` - 复杂的模型路由逻辑
- `apps/web/src/contexts/ThreadProvider.tsx` - 模型配置初始化
- `apps/web/src/components/chat-interface/model-selector/` - 模型选择器组件

### 1.2 智能体配置问题

**问题描述：**
- 智能体创建和编辑流程复杂
- 配置界面分散，用户体验不佳
- 缺乏配置验证和错误提示
- 工具配置和系统提示管理混乱

**影响范围：**
- `apps/web/src/contexts/AssistantContext.tsx` - 435行复杂逻辑
- `apps/web/src/components/assistant-select/` - 智能体选择组件
- 智能体配置表单和验证逻辑

### 1.3 错误处理问题

**问题描述：**
- 错误处理不统一，缺乏标准化
- 用户友好的错误信息不足
- 缺乏错误恢复机制
- 调试信息不充分

**影响范围：**
- API 路由错误处理
- 前端组件错误边界
- 模型调用异常处理
- 数据库连接错误处理

## 2. 重构目标

### 2.1 主要目标

1. **简化模型配置**：实现动态模型配置，减少硬编码
2. **优化智能体配置**：提供直观的配置界面和流程
3. **统一错误处理**：建立标准化的错误处理机制
4. **提升代码质量**：消除重复代码，优化架构
5. **性能优化**：改善响应速度和资源利用

### 2.2 技术目标

- 减少代码重复度 30%+
- 提升新增模型配置效率 80%+
- 改善错误处理覆盖率 90%+
- 优化页面加载速度 20%+
- 提升代码可维护性

## 3. 详细重构计划

### 3.1 模型配置系统重构

#### 3.1.1 创建模型配置管理器

**目标：** 统一模型配置管理，支持动态配置

**实现方案：**

1. **创建模型配置接口**
```typescript
// packages/shared/src/config/model-config.ts
export interface ModelProviderConfig {
  name: string;
  displayName: string;
  apiKey: string;
  baseUrl?: string;
  customHeaders?: Record<string, string>;
  supportedFeatures: {
    toolCalling: boolean;
    streaming: boolean;
    temperature: boolean;
    maxTokens: number;
  };
}

export interface ModelDefinition {
  id: string;
  name: string;
  displayName: string;
  provider: string;
  providerConfig: ModelProviderConfig;
  capabilities: {
    maxTokens: number;
    temperatureRange: { min: number; max: number; default: number };
    supportsToolCalling: boolean;
    supportsStreaming: boolean;
  };
  metadata: {
    isNew: boolean;
    category: string;
    description?: string;
  };
}
```

2. **实现动态模型注册器**
```typescript
// packages/shared/src/config/model-registry.ts
export class ModelRegistry {
  private static instance: ModelRegistry;
  private models: Map<string, ModelDefinition> = new Map();
  private providers: Map<string, ModelProviderConfig> = new Map();

  static getInstance(): ModelRegistry {
    if (!ModelRegistry.instance) {
      ModelRegistry.instance = new ModelRegistry();
    }
    return ModelRegistry.instance;
  }

  registerProvider(config: ModelProviderConfig): void {
    this.providers.set(config.name, config);
  }

  registerModel(model: ModelDefinition): void {
    this.models.set(model.id, model);
  }

  getModel(id: string): ModelDefinition | undefined {
    return this.models.get(id);
  }

  getAllModels(): ModelDefinition[] {
    return Array.from(this.models.values());
  }

  getModelsByProvider(provider: string): ModelDefinition[] {
    return Array.from(this.models.values())
      .filter(model => model.provider === provider);
  }
}
```

3. **配置文件驱动**
```typescript
// config/models.json
{
  "providers": {
    "openai": {
      "name": "openai",
      "displayName": "OpenAI",
      "apiKey": "${OPENAI_API_KEY}",
      "supportedFeatures": {
        "toolCalling": true,
        "streaming": true,
        "temperature": true,
        "maxTokens": 100000
      }
    }
  },
  "models": {
    "gpt-4o": {
      "id": "gpt-4o",
      "name": "gpt-4o",
      "displayName": "GPT-4o",
      "provider": "openai",
      "capabilities": {
        "maxTokens": 16384,
        "temperatureRange": { "min": 0, "max": 1, "default": 0.5 },
        "supportsToolCalling": true,
        "supportsStreaming": true
      },
      "metadata": {
        "isNew": false,
        "category": "general",
        "description": "Latest GPT-4 model"
      }
    }
  }
}
```

#### 3.1.2 重构模型选择器组件

**目标：** 简化模型选择逻辑，提升用户体验

**实现方案：**

1. **统一模型选择器**
```typescript
// apps/web/src/components/model-selector/ModelSelector.tsx
interface ModelSelectorProps {
  selectedModel: string;
  onModelChange: (modelId: string) => void;
  disabled?: boolean;
  showConfig?: boolean;
}

export function ModelSelector({ 
  selectedModel, 
  onModelChange, 
  disabled = false,
  showConfig = true 
}: ModelSelectorProps) {
  const { models, providers } = useModelRegistry();
  const [searchTerm, setSearchTerm] = useState('');
  
  const filteredModels = useMemo(() => {
    return models.filter(model => 
      model.displayName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      model.metadata.category.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [models, searchTerm]);

  return (
    <div className="model-selector">
      <SearchInput 
        value={searchTerm}
        onChange={setSearchTerm}
        placeholder="搜索模型..."
      />
      <ModelList 
        models={filteredModels}
        selectedModel={selectedModel}
        onModelSelect={onModelChange}
        showConfig={showConfig}
      />
    </div>
  );
}
```

2. **模型配置面板优化**
```typescript
// apps/web/src/components/model-selector/ModelConfigPanel.tsx
interface ModelConfigPanelProps {
  model: ModelDefinition;
  config: ModelConfig;
  onConfigChange: (config: ModelConfig) => void;
}

export function ModelConfigPanel({ 
  model, 
  config, 
  onConfigChange 
}: ModelConfigPanelProps) {
  const { capabilities } = model;
  
  return (
    <div className="model-config-panel">
      <ConfigSection title="基础设置">
        <TemperatureSlider
          value={config.temperature}
          range={capabilities.temperatureRange}
          onChange={(temp) => onConfigChange({ ...config, temperature: temp })}
          disabled={!capabilities.supportsTemperature}
        />
        <MaxTokensInput
          value={config.maxTokens}
          max={capabilities.maxTokens}
          onChange={(tokens) => onConfigChange({ ...config, maxTokens: tokens })}
        />
      </ConfigSection>
      
      <ConfigSection title="高级设置">
        <ToolCallingToggle
          enabled={config.toolCalling}
          onChange={(enabled) => onConfigChange({ ...config, toolCalling: enabled })}
          disabled={!capabilities.supportsToolCalling}
        />
        <StreamingToggle
          enabled={config.streaming}
          onChange={(enabled) => onConfigChange({ ...config, streaming: enabled })}
          disabled={!capabilities.supportsStreaming}
        />
      </ConfigSection>
    </div>
  );
}
```

#### 3.1.3 简化模型调用逻辑

**目标：** 统一模型调用接口，减少重复代码

**实现方案：**

1. **统一模型调用器**
```typescript
// apps/agents/src/models/ModelInvoker.ts
export class ModelInvoker {
  private registry: ModelRegistry;
  
  constructor() {
    this.registry = ModelRegistry.getInstance();
  }

  async invokeModel(
    modelId: string, 
    messages: BaseMessage[], 
    config: ModelConfig,
    options?: InvokeOptions
  ): Promise<ModelResponse> {
    const model = this.registry.getModel(modelId);
    if (!model) {
      throw new ModelNotFoundError(`Model ${modelId} not found`);
    }

    const provider = this.registry.getProvider(model.provider);
    if (!provider) {
      throw new ProviderNotFoundError(`Provider ${model.provider} not found`);
    }

    try {
      const client = this.createModelClient(model, provider, config);
      const response = await client.invoke(messages, options);
      return this.processResponse(response, model);
    } catch (error) {
      throw new ModelInvocationError(
        `Failed to invoke model ${modelId}: ${error.message}`,
        { modelId, error }
      );
    }
  }

  private createModelClient(
    model: ModelDefinition, 
    provider: ModelProviderConfig, 
    config: ModelConfig
  ): ModelClient {
    // 统一的客户端创建逻辑
    switch (provider.name) {
      case 'openai':
        return new OpenAIClient(model, provider, config);
      case 'anthropic':
        return new AnthropicClient(model, provider, config);
      case 'google':
        return new GoogleClient(model, provider, config);
      default:
        throw new UnsupportedProviderError(`Provider ${provider.name} not supported`);
    }
  }
}
```

### 3.2 智能体配置系统重构

#### 3.2.1 创建智能体配置管理器

**目标：** 简化智能体创建和配置流程

**实现方案：**

1. **智能体配置接口**
```typescript
// packages/shared/src/config/assistant-config.ts
export interface AssistantConfig {
  id: string;
  name: string;
  description?: string;
  icon: {
    name: string;
    color: string;
  };
  model: {
    id: string;
    config: ModelConfig;
  };
  systemPrompt?: string;
  tools: AssistantTool[];
  documents: ContextDocument[];
  metadata: {
    isDefault: boolean;
    createdAt: Date;
    updatedAt: Date;
    userId: string;
  };
}

export interface AssistantTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  config: Partial<AssistantConfig>;
  preview: {
    icon: string;
    color: string;
    description: string;
  };
}
```

2. **智能体配置构建器**
```typescript
// apps/web/src/components/assistant-config/AssistantConfigBuilder.tsx
interface AssistantConfigBuilderProps {
  initialConfig?: Partial<AssistantConfig>;
  onSave: (config: AssistantConfig) => Promise<void>;
  onCancel: () => void;
}

export function AssistantConfigBuilder({ 
  initialConfig, 
  onSave, 
  onCancel 
}: AssistantConfigBuilderProps) {
  const [config, setConfig] = useState<AssistantConfig>(
    initialConfig || getDefaultAssistantConfig()
  );
  const [currentStep, setCurrentStep] = useState(0);
  const [isValidating, setIsValidating] = useState(false);

  const steps = [
    { id: 'basic', title: '基础信息', component: BasicInfoStep },
    { id: 'model', title: '模型配置', component: ModelConfigStep },
    { id: 'prompt', title: '系统提示', component: SystemPromptStep },
    { id: 'tools', title: '工具配置', component: ToolsConfigStep },
    { id: 'review', title: '预览确认', component: ReviewStep },
  ];

  const handleNext = async () => {
    setIsValidating(true);
    try {
      const isValid = await validateStep(currentStep, config);
      if (isValid) {
        setCurrentStep(prev => Math.min(prev + 1, steps.length - 1));
      }
    } finally {
      setIsValidating(false);
    }
  };

  const handleSave = async () => {
    setIsValidating(true);
    try {
      const validatedConfig = await validateConfig(config);
      await onSave(validatedConfig);
    } catch (error) {
      showError('保存智能体配置失败', error);
    } finally {
      setIsValidating(false);
    }
  };

  return (
    <div className="assistant-config-builder">
      <StepIndicator 
        steps={steps} 
        currentStep={currentStep}
        onStepClick={setCurrentStep}
      />
      
      <div className="config-content">
        {React.createElement(steps[currentStep].component, {
          config,
          onChange: setConfig,
          onNext: handleNext,
          onPrevious: () => setCurrentStep(prev => Math.max(prev - 1, 0)),
          onSave: handleSave,
          isValidating,
        })}
      </div>
    </div>
  );
}
```

#### 3.2.2 智能体模板系统

**目标：** 提供预设的智能体模板，简化创建流程

**实现方案：**

1. **模板定义**
```typescript
// config/assistant-templates.json
{
  "templates": [
    {
      "id": "coding-assistant",
      "name": "编程助手",
      "description": "专业的代码编写和调试助手",
      "category": "development",
      "config": {
        "model": {
          "id": "gpt-4o",
          "config": {
            "temperature": 0.3,
            "maxTokens": 8192,
            "toolCalling": true
          }
        },
        "systemPrompt": "你是一个专业的编程助手，擅长多种编程语言...",
        "tools": [
          {
            "name": "code_generator",
            "description": "生成代码",
            "parameters": { /* schema */ }
          }
        ]
      },
      "preview": {
        "icon": "Code",
        "color": "#3B82F6",
        "description": "帮助您编写、调试和优化代码"
      }
    }
  ]
}
```

2. **模板选择器**
```typescript
// apps/web/src/components/assistant-config/TemplateSelector.tsx
export function TemplateSelector({ 
  onTemplateSelect, 
  onCustomCreate 
}: TemplateSelectorProps) {
  const { templates, categories } = useAssistantTemplates();
  const [selectedCategory, setSelectedCategory] = useState('all');

  const filteredTemplates = useMemo(() => {
    if (selectedCategory === 'all') return templates;
    return templates.filter(t => t.category === selectedCategory);
  }, [templates, selectedCategory]);

  return (
    <div className="template-selector">
      <CategoryFilter 
        categories={categories}
        selectedCategory={selectedCategory}
        onCategoryChange={setSelectedCategory}
      />
      
      <TemplateGrid 
        templates={filteredTemplates}
        onTemplateSelect={onTemplateSelect}
      />
      
      <CustomCreateButton onClick={onCustomCreate} />
    </div>
  );
}
```

### 3.3 错误处理系统重构

#### 3.3.1 统一错误处理架构

**目标：** 建立标准化的错误处理机制

**实现方案：**

1. **错误类型定义**
```typescript
// packages/shared/src/errors/ErrorTypes.ts
export enum ErrorCode {
  // 认证错误
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  
  // 模型错误
  MODEL_NOT_FOUND = 'MODEL_NOT_FOUND',
  MODEL_INVOCATION_FAILED = 'MODEL_INVOCATION_FAILED',
  PROVIDER_NOT_FOUND = 'PROVIDER_NOT_FOUND',
  
  // 智能体错误
  ASSISTANT_NOT_FOUND = 'ASSISTANT_NOT_FOUND',
  ASSISTANT_CREATION_FAILED = 'ASSISTANT_CREATION_FAILED',
  
  // 网络错误
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  
  // 验证错误
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_INPUT = 'INVALID_INPUT',
  
  // 系统错误
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
}

export interface AppError {
  code: ErrorCode;
  message: string;
  details?: any;
  timestamp: Date;
  context?: {
    userId?: string;
    requestId?: string;
    component?: string;
  };
}

export class AppError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public details?: any,
    public context?: any
  ) {
    super(message);
    this.name = 'AppError';
    this.timestamp = new Date();
  }
}
```

2. **错误处理器**
```typescript
// apps/web/src/lib/error-handler/ErrorHandler.ts
export class ErrorHandler {
  private static instance: ErrorHandler;
  private errorLogger: ErrorLogger;
  private errorNotifier: ErrorNotifier;

  static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }

  async handleError(error: Error, context?: ErrorContext): Promise<ErrorResponse> {
    const appError = this.normalizeError(error);
    
    // 记录错误
    await this.errorLogger.log(appError, context);
    
    // 通知用户
    const userMessage = this.getUserFriendlyMessage(appError);
    this.errorNotifier.notify(userMessage, appError.code);
    
    // 返回标准错误响应
    return {
      code: appError.code,
      message: userMessage,
      details: this.getErrorDetails(appError),
      timestamp: appError.timestamp,
    };
  }

  private normalizeError(error: Error): AppError {
    if (error instanceof AppError) {
      return error;
    }

    // 根据错误类型映射到标准错误代码
    if (error.name === 'NetworkError') {
      return new AppError(ErrorCode.NETWORK_ERROR, error.message);
    }
    
    if (error.message.includes('timeout')) {
      return new AppError(ErrorCode.TIMEOUT_ERROR, error.message);
    }

    return new AppError(ErrorCode.INTERNAL_ERROR, error.message);
  }

  private getUserFriendlyMessage(error: AppError): string {
    const messages = {
      [ErrorCode.UNAUTHORIZED]: '请先登录后再进行操作',
      [ErrorCode.MODEL_NOT_FOUND]: '选择的模型不存在，请重新选择',
      [ErrorCode.NETWORK_ERROR]: '网络连接异常，请检查网络后重试',
      [ErrorCode.VALIDATION_ERROR]: '输入信息有误，请检查后重试',
      [ErrorCode.INTERNAL_ERROR]: '系统内部错误，请稍后重试',
    };

    return messages[error.code] || '操作失败，请稍后重试';
  }
}
```

3. **错误边界组件**
```typescript
// apps/web/src/components/error-boundary/ErrorBoundary.tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error?: AppError;
  errorInfo?: ErrorInfo;
}

export class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error: error instanceof AppError ? error : new AppError(
        ErrorCode.INTERNAL_ERROR,
        error.message
      ),
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const errorHandler = ErrorHandler.getInstance();
    errorHandler.handleError(error, {
      component: this.props.componentName,
      errorInfo,
    });

    this.setState({ errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return (
        <ErrorFallback
          error={this.state.error}
          onRetry={() => this.setState({ hasError: false })}
          onReport={() => this.reportError()}
        />
      );
    }

    return this.props.children;
  }
}
```

#### 3.3.2 API 错误处理优化

**目标：** 统一 API 错误响应格式

**实现方案：**

1. **API 错误响应中间件**
```typescript
// apps/web/src/app/api/middleware/error-handler.ts
export function withErrorHandler<T extends any[]>(
  handler: (...args: T) => Promise<NextResponse>
) {
  return async (...args: T): Promise<NextResponse> => {
    try {
      return await handler(...args);
    } catch (error) {
      const errorHandler = ErrorHandler.getInstance();
      const errorResponse = await errorHandler.handleError(error, {
        endpoint: args[0]?.nextUrl?.pathname,
        method: args[0]?.method,
      });

      return NextResponse.json(
        {
          success: false,
          error: errorResponse,
        },
        { 
          status: getHttpStatusFromErrorCode(errorResponse.code),
          headers: getCorsHeaders(),
        }
      );
    }
  };
}

function getHttpStatusFromErrorCode(code: ErrorCode): number {
  const statusMap = {
    [ErrorCode.UNAUTHORIZED]: 401,
    [ErrorCode.FORBIDDEN]: 403,
    [ErrorCode.MODEL_NOT_FOUND]: 404,
    [ErrorCode.VALIDATION_ERROR]: 400,
    [ErrorCode.NETWORK_ERROR]: 502,
    [ErrorCode.SERVICE_UNAVAILABLE]: 503,
    [ErrorCode.INTERNAL_ERROR]: 500,
  };

  return statusMap[code] || 500;
}
```

2. **客户端错误处理 Hook**
```typescript
// apps/web/src/hooks/useErrorHandler.ts
export function useErrorHandler() {
  const { toast } = useToast();
  const errorHandler = ErrorHandler.getInstance();

  const handleError = useCallback(async (
    error: Error, 
    context?: ErrorContext
  ) => {
    const errorResponse = await errorHandler.handleError(error, context);
    
    toast({
      title: '操作失败',
      description: errorResponse.message,
      variant: 'destructive',
      duration: 5000,
    });

    return errorResponse;
  }, [toast, errorHandler]);

  const handleAsync = useCallback(async <T>(
    asyncFn: () => Promise<T>,
    context?: ErrorContext
  ): Promise<T | null> => {
    try {
      return await asyncFn();
    } catch (error) {
      await handleError(error as Error, context);
      return null;
    }
  }, [handleError]);

  return { handleError, handleAsync };
}
```

### 3.4 性能优化

#### 3.4.1 缓存策略优化

**目标：** 实现智能缓存，提升响应速度

**实现方案：**

1. **多级缓存系统**
```typescript
// apps/web/src/lib/cache/CacheManager.ts
export class CacheManager {
  private memoryCache: Map<string, CacheItem> = new Map();
  private redisClient?: RedisClient;
  private cacheConfig: CacheConfig;

  constructor(config: CacheConfig) {
    this.cacheConfig = config;
    this.initializeRedis();
  }

  async get<T>(key: string): Promise<T | null> {
    // 1. 检查内存缓存
    const memoryItem = this.memoryCache.get(key);
    if (memoryItem && !this.isExpired(memoryItem)) {
      return memoryItem.data as T;
    }

    // 2. 检查 Redis 缓存
    if (this.redisClient) {
      try {
        const redisData = await this.redisClient.get(key);
        if (redisData) {
          const item = JSON.parse(redisData) as CacheItem;
          if (!this.isExpired(item)) {
            // 回写到内存缓存
            this.memoryCache.set(key, item);
            return item.data as T;
          }
        }
      } catch (error) {
        console.warn('Redis cache read failed:', error);
      }
    }

    return null;
  }

  async set<T>(
    key: string, 
    data: T, 
    ttl: number = this.cacheConfig.defaultTtl
  ): Promise<void> {
    const item: CacheItem = {
      data,
      timestamp: Date.now(),
      ttl,
    };

    // 写入内存缓存
    this.memoryCache.set(key, item);

    // 写入 Redis 缓存
    if (this.redisClient) {
      try {
        await this.redisClient.setex(key, ttl, JSON.stringify(item));
      } catch (error) {
        console.warn('Redis cache write failed:', error);
      }
    }
  }

  private isExpired(item: CacheItem): boolean {
    return Date.now() - item.timestamp > item.ttl * 1000;
  }
}
```

2. **模型配置缓存**
```typescript
// apps/web/src/hooks/useModelCache.ts
export function useModelCache() {
  const cacheManager = CacheManager.getInstance();
  
  const getCachedModels = useCallback(async (): Promise<ModelDefinition[]> => {
    const cacheKey = 'models:all';
    const cached = await cacheManager.get<ModelDefinition[]>(cacheKey);
    
    if (cached) {
      return cached;
    }

    // 从 API 获取模型列表
    const models = await fetchModels();
    
    // 缓存 5 分钟
    await cacheManager.set(cacheKey, models, 300);
    
    return models;
  }, [cacheManager]);

  const invalidateModelCache = useCallback(async () => {
    await cacheManager.delete('models:all');
  }, [cacheManager]);

  return { getCachedModels, invalidateModelCache };
}
```

#### 3.4.2 代码分割优化

**目标：** 减少初始加载时间，提升用户体验

**实现方案：**

1. **路由级代码分割**
```typescript
// apps/web/src/app/layout.tsx
import dynamic from 'next/dynamic';

// 动态导入重型组件
const ModelSelector = dynamic(
  () => import('@/components/model-selector/ModelSelector'),
  { 
    loading: () => <ModelSelectorSkeleton />,
    ssr: false 
  }
);

const AssistantConfigBuilder = dynamic(
  () => import('@/components/assistant-config/AssistantConfigBuilder'),
  { 
    loading: () => <ConfigBuilderSkeleton />,
    ssr: false 
  }
);
```

2. **组件级懒加载**
```typescript
// apps/web/src/components/lazy/LazyComponents.tsx
export const LazyModelConfigPanel = lazy(() => 
  import('../model-selector/ModelConfigPanel')
);

export const LazyAssistantList = lazy(() => 
  import('../assistant-select/AssistantList')
);

export const LazyArtifactEditor = lazy(() => 
  import('../artifacts/ArtifactEditor')
);
```

#### 3.4.3 内存管理优化

**目标：** 减少内存泄漏，提升长期运行稳定性

**实现方案：**

1. **资源清理 Hook**
```typescript
// apps/web/src/hooks/useResourceCleanup.ts
export function useResourceCleanup() {
  const cleanupFunctions = useRef<(() => void)[]>([]);

  const addCleanup = useCallback((cleanup: () => void) => {
    cleanupFunctions.current.push(cleanup);
  }, []);

  const cleanup = useCallback(() => {
    cleanupFunctions.current.forEach(fn => {
      try {
        fn();
      } catch (error) {
        console.warn('Cleanup function failed:', error);
      }
    });
    cleanupFunctions.current = [];
  }, []);

  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  return { addCleanup, cleanup };
}
```

2. **智能体状态管理优化**
```typescript
// apps/web/src/contexts/AssistantContext.tsx
export function AssistantProvider({ children }: { children: ReactNode }) {
  const [assistants, setAssistants] = useState<Assistant[]>([]);
  const [selectedAssistant, setSelectedAssistant] = useState<Assistant>();
  
  // 使用 useMemo 避免不必要的重新计算
  const assistantMap = useMemo(() => {
    return new Map(assistants.map(a => [a.assistant_id, a]));
  }, [assistants]);

  // 使用 useCallback 避免不必要的重新渲染
  const updateAssistant = useCallback((id: string, updates: Partial<Assistant>) => {
    setAssistants(prev => prev.map(a => 
      a.assistant_id === id ? { ...a, ...updates } : a
    ));
  }, []);

  // 清理函数
  useEffect(() => {
    return () => {
      // 清理定时器、事件监听器等
      setAssistants([]);
      setSelectedAssistant(undefined);
    };
  }, []);

  // ... 其他逻辑
}
```

### 3.5 代码质量提升

#### 3.5.1 消除重复代码

**目标：** 提取公共逻辑，减少代码重复

**实现方案：**

1. **通用 Hook 提取**
```typescript
// apps/web/src/hooks/common/useAsyncOperation.ts
export function useAsyncOperation<T, P extends any[]>(
  operation: (...args: P) => Promise<T>,
  options: AsyncOperationOptions = {}
) {
  const [state, setState] = useState<AsyncOperationState<T>>({
    data: null,
    loading: false,
    error: null,
  });

  const execute = useCallback(async (...args: P) => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const result = await operation(...args);
      setState({ data: result, loading: false, error: null });
      return result;
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error as Error 
      }));
      throw error;
    }
  }, [operation]);

  const reset = useCallback(() => {
    setState({ data: null, loading: false, error: null });
  }, []);

  return { ...state, execute, reset };
}
```

2. **通用组件提取**
```typescript
// apps/web/src/components/common/ConfigForm.tsx
interface ConfigFormProps<T> {
  initialData: T;
  schema: ValidationSchema<T>;
  onSubmit: (data: T) => Promise<void>;
  onCancel: () => void;
  children: (props: ConfigFormChildrenProps<T>) => ReactNode;
}

export function ConfigForm<T>({
  initialData,
  schema,
  onSubmit,
  onCancel,
  children,
}: ConfigFormProps<T>) {
  const [data, setData] = useState<T>(initialData);
  const [errors, setErrors] = useState<ValidationErrors<T>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const validate = useCallback((data: T) => {
    const validationErrors = validateData(data, schema);
    setErrors(validationErrors);
    return Object.keys(validationErrors).length === 0;
  }, [schema]);

  const handleSubmit = useCallback(async () => {
    if (!validate(data)) return;

    setIsSubmitting(true);
    try {
      await onSubmit(data);
    } catch (error) {
      console.error('Form submission failed:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [data, validate, onSubmit]);

  return (
    <form onSubmit={handleSubmit}>
      {children({
        data,
        setData,
        errors,
        isSubmitting,
        onSubmit: handleSubmit,
        onCancel,
      })}
    </form>
  );
}
```

#### 3.5.2 现代化语法更新

**目标：** 使用现代 TypeScript 和 React 特性

**实现方案：**

1. **使用现代 React 特性**
```typescript
// 使用 useTransition 优化用户体验
export function ModelSelector() {
  const [isPending, startTransition] = useTransition();
  const [models, setModels] = useState<ModelDefinition[]>([]);

  const loadModels = useCallback(() => {
    startTransition(async () => {
      const newModels = await fetchModels();
      setModels(newModels);
    });
  }, []);

  return (
    <div>
      {isPending && <LoadingSpinner />}
      <ModelList models={models} />
    </div>
  );
}

// 使用 useDeferredValue 优化性能
export function ModelSearch() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  const filteredModels = useMemo(() => {
    return models.filter(model => 
      model.name.toLowerCase().includes(deferredQuery.toLowerCase())
    );
  }, [models, deferredQuery]);

  return (
    <div>
      <SearchInput value={query} onChange={setQuery} />
      <ModelList models={filteredModels} />
    </div>
  );
}
```

2. **使用现代 TypeScript 特性**
```typescript
// 使用模板字面量类型
type ModelId = `model-${string}`;
type ProviderId = `provider-${string}`;

// 使用条件类型
type ModelConfig<T extends ModelId> = 
  T extends `model-openai-${string}` ? OpenAIConfig :
  T extends `model-anthropic-${string}` ? AnthropicConfig :
  T extends `model-google-${string}` ? GoogleConfig :
  DefaultConfig;

// 使用映射类型
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// 使用工具类型
interface ModelDefinition {
  id: ModelId;
  name: string;
  config: ModelConfig<ModelId>;
}

type CreateModelRequest = PartialBy<ModelDefinition, 'id'>;
type UpdateModelRequest = RequiredBy<Partial<ModelDefinition>, 'id'>;
```

## 4. 实施计划

### 4.1 阶段划分

#### 第一阶段：基础架构重构（2-3周）
- 创建模型配置管理器
- 实现统一错误处理系统
- 建立缓存基础设施
- 完成基础组件重构

#### 第二阶段：功能优化（2-3周）
- 重构模型选择器组件
- 优化智能体配置流程
- 实现性能优化措施
- 完善错误处理覆盖

#### 第三阶段：质量提升（1-2周）
- 代码质量优化
- 测试覆盖完善
- 文档更新
- 性能测试和优化

### 4.2 风险评估

#### 高风险项
- 模型配置系统重构可能影响现有功能
- 错误处理变更可能影响用户体验
- 性能优化可能引入新的问题

#### 风险缓解措施
- 分阶段实施，逐步迁移
- 保持向后兼容性
- 充分的测试覆盖
- 回滚方案准备

### 4.3 成功指标

#### 技术指标
- 代码重复度减少 30%+
- 新增模型配置时间减少 80%+
- 错误处理覆盖率 90%+
- 页面加载速度提升 20%+

#### 用户体验指标
- 模型配置流程简化
- 智能体创建时间减少
- 错误信息更加友好
- 整体操作流畅度提升

## 5. 总结

本重构计划通过系统性的架构优化，将显著改善 Open Canvas 项目的可维护性、性能和用户体验。通过分阶段实施，可以确保重构过程的安全性和可控性，最终实现项目的现代化升级。

重构完成后，项目将具备：
- 灵活的模型配置系统
- 直观的智能体配置流程
- 完善的错误处理机制
- 优秀的性能表现
- 高质量的代码结构

这将为项目的长期发展奠定坚实的基础，提升开发效率和用户体验。
